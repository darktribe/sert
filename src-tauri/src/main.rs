// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

/*
 * =====================================================
 * Sert Editor - Rust„Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâÔºàTauri 2.6ÂØæÂøúÁâàÔºâ
 * PythonÊã°ÂºµÊ©üËÉΩÂØæÂøú„ÅÆ„Ç∑„É≥„Éó„É´„Å™„ÉÜ„Ç≠„Çπ„Éà„Ç®„Éá„Ç£„Çø
 * „Éâ„É©„ÉÉ„Ç∞„Ç¢„É≥„Éâ„Éâ„É≠„ÉÉ„Éó„Éª„Éï„Ç°„Ç§„É´Èñ¢ÈÄ£‰ªò„ÅëÂØæÂøú
 * =====================================================
 */

use pyo3::prelude::*;
use pyo3::types::PyDict;
use tauri::{Manager, Emitter, AppHandle, WebviewWindow};

// =====================================================
// „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂàùÊúüÂåñ„Å®„Éï„Ç°„Ç§„É´Èñ¢ÈÄ£‰ªò„Åë
// =====================================================

/**
 * Ëµ∑ÂãïÊôÇ„ÅÆ„Éï„Ç°„Ç§„É´„Éë„Çπ„ÇíÂèñÂæó„Åô„Çã„Ç≥„Éû„É≥„Éâ
 * „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„Åã„ÇâÊ∏°„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„Éë„Çπ„ÇíËøî„Åô
 */
#[tauri::command]
fn get_startup_file_path() -> Result<Option<String>, String> {
    let args: Vec<String> = std::env::args().collect();
    
    // ÊúÄÂàù„ÅÆÂºïÊï∞ÔºàÂÆüË°å„Éï„Ç°„Ç§„É´„Éë„ÇπÔºâ„ÇíÈô§„ÅÑ„Å¶„ÄÅ„Éï„Ç°„Ç§„É´„Éë„Çπ„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    if args.len() > 1 {
        let file_path = &args[1];
        
        // „Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        if std::path::Path::new(file_path).exists() {
            println!("üìÇ Startup file detected: {}", file_path);
            return Ok(Some(file_path.clone()));
        } else {
            println!("‚ö†Ô∏è Startup file does not exist: {}", file_path);
        }
    }
    
    Ok(None)
}

/**
 * „Éï„Ç°„Ç§„É´„Éë„Çπ„ÅåÊúâÂäπ„Åã„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã„Ç≥„Éû„É≥„Éâ
 */
#[tauri::command]
fn validate_file_path(path: String) -> Result<bool, String> {
    let file_path = std::path::Path::new(&path);
    
    if file_path.exists() && file_path.is_file() {
        println!("‚úÖ Valid file path: {}", path);
        Ok(true)
    } else {
        println!("‚ùå Invalid file path: {}", path);
        Ok(false)
    }
}

/**
 * „Éï„Ç°„Ç§„É´„ÅÆÂü∫Êú¨ÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã„Ç≥„Éû„É≥„Éâ
 */
#[tauri::command]
fn get_file_info(path: String) -> Result<serde_json::Value, String> {
    let file_path = std::path::Path::new(&path);
    
    if !file_path.exists() {
        return Err(format!("File does not exist: {}", path));
    }
    
    if !file_path.is_file() {
        return Err(format!("Path is not a file: {}", path));
    }
    
    let metadata = std::fs::metadata(&path).map_err(|e| format!("Failed to get metadata: {}", e))?;
    let file_size = metadata.len();
    
    let file_name = file_path.file_name()
        .and_then(|name| name.to_str())
        .unwrap_or("Unknown")
        .to_string();
    
    let file_extension = file_path.extension()
        .and_then(|ext| ext.to_str())
        .unwrap_or("")
        .to_string();
    
    let info = serde_json::json!({
        "name": file_name,
        "extension": file_extension,
        "size": file_size,
        "path": path
    });
    
    println!("üìã File info: {}", info);
    Ok(info)
}

// =====================================================
// PythonÁµ±ÂêàÊ©üËÉΩÔºàPyO3Ôºâ
// =====================================================

/**
 * PyO3„ÅÆÂü∫Êú¨„ÉÜ„Çπ„ÉàÈñ¢Êï∞
 * PythonÁí∞Â¢É„ÅåÊ≠£Â∏∏„Å´Âãï‰Ωú„Åô„Çã„Åã„ÉÜ„Çπ„Éà„Åô„Çã
 */
#[tauri::command]
fn test_python() -> Result<String, String> {
    Python::with_gil(|py| {
        let result = py.eval_bound("2 + 2", None, None);
        match result {
            Ok(val) => Ok(format!("Python result: {}", val)),
            Err(e) => Err(format!("Python error: {}", e)),
        }
    })
}

/**
 * ‰ªªÊÑè„ÅÆPython„Ç≥„Éº„Éâ„ÇíÂÆüË°å
 * Ê©üËÉΩÊã°Âºµ„Åß‰ΩøÁî®„Åï„Çå„Çã‰∫àÂÆö
 */
#[tauri::command]
fn execute_python(code: String) -> Result<String, String> {
    Python::with_gil(|py| {
        let locals = PyDict::new_bound(py);
        match py.run_bound(&code, None, Some(&locals)) {
            Ok(_) => {
                // ÁµêÊûú„ÇíÂèñÂæó„Åô„ÇãÂ†¥ÂêàÔºà‰æãÔºöÊúÄÂæå„ÅÆÂ§âÊï∞„ÅÆÂÄ§Ôºâ
                match locals.get_item("result") {
                    Ok(Some(val)) => Ok(format!("{}", val)),
                    _ => Ok("Code executed successfully".to_string()),
                }
            },
            Err(e) => Err(format!("Python execution error: {}", e)),
        }
    })
}

/**
 * PythonÂºè„ÇíË©ï‰æ°„Åô„ÇãÈñ¢Êï∞
 * Ê©üËÉΩÊã°Âºµ„Åß‰ΩøÁî®„Åï„Çå„Çã‰∫àÂÆö
 */
#[tauri::command]
fn evaluate_python_expression(expression: String) -> Result<String, String> {
    Python::with_gil(|py| {
        match py.eval_bound(&expression, None, None) {
            Ok(val) => Ok(format!("{}", val)),
            Err(e) => Err(format!("Python evaluation error: {}", e)),
        }
    })
}

/**
 * Python„Éï„Ç°„Ç§„É´„ÇíÂÆüË°å„Åô„ÇãÈñ¢Êï∞
 * Ê©üËÉΩÊã°ÂºµË™≠„ÅøËæº„Åø„Åß‰ΩøÁî®„Åï„Çå„Çã‰∫àÂÆö
 */
#[tauri::command]
fn run_python_file(file_path: String) -> Result<String, String> {
    Python::with_gil(|py| {
        match std::fs::read_to_string(&file_path) {
            Ok(code) => {
                let locals = PyDict::new_bound(py);
                match py.run_bound(&code, None, Some(&locals)) {
                    Ok(_) => Ok("Python file executed successfully".to_string()),
                    Err(e) => Err(format!("Python file execution error: {}", e)),
                }
            },
            Err(e) => Err(format!("Failed to read Python file: {}", e)),
        }
    })
}

/**
 * Python„ÅÆ„Éê„Éº„Ç∏„Éß„É≥ÊÉÖÂ†±„ÇíÂèñÂæó
 * „Éá„Éê„ÉÉ„Ç∞„ÉªÁí∞Â¢ÉÁ¢∫Ë™çÁî®
 */
#[tauri::command]
fn get_python_info() -> Result<String, String> {
    Python::with_gil(|py| {
        let code = "import sys\nresult = sys.version";
        let locals = PyDict::new_bound(py);
        match py.run_bound(code, None, Some(&locals)) {
            Ok(_) => {
                match locals.get_item("result") {
                    Ok(Some(version)) => Ok(format!("Python version: {}", version)),
                    _ => Err("Could not get version info".to_string()),
                }
            },
            Err(e) => Err(format!("Failed to get Python info: {}", e)),
        }
    })
}

// =====================================================
// „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Âà∂Âæ°
// =====================================================

/**
 * „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÁµÇ‰∫Ü„Ç≥„Éû„É≥„Éâ
 * Âç≥Â∫ß„Å´Âº∑Âà∂ÁµÇ‰∫Ü„Åô„Çã
 */
#[tauri::command]
fn exit_app() {
    println!("üî• Exit app command called - immediate shutdown");
    std::process::exit(0);
}

// =====================================================
// „ÇØ„É™„ÉÉ„Éó„Éú„Éº„ÉâÊìç‰ΩúÔºà„ÇØ„É≠„Çπ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†ÂØæÂøúÔºâ
// =====================================================

/**
 * „ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„ÉÜ„Ç≠„Çπ„Éà„ÇíÊõ∏„ÅçËæº„ÇÄ
 * Windows/macOS/LinuxÂØæÂøú
 */
#[tauri::command]
fn write_clipboard(text: String) -> Result<(), String> {
    println!("üìã Writing to clipboard: {} characters", text.len());
    
    #[cfg(target_os = "windows")]
    {
        use std::process::Command;
        let mut child = Command::new("cmd")
            .args(["/C", "echo", &text, "|", "clip"])
            .spawn()
            .map_err(|e| format!("Failed to spawn clipboard command: {}", e))?;
        
        let status = child.wait()
            .map_err(|e| format!("Failed to wait for clipboard command: {}", e))?;
        
        if status.success() {
            println!("‚úÖ Clipboard write successful (Windows)");
            Ok(())
        } else {
            Err("Clipboard write failed (Windows)".to_string())
        }
    }
    
    #[cfg(target_os = "macos")]
    {
        use std::process::{Command, Stdio};
        use std::io::Write;
        
        let mut child = Command::new("pbcopy")
            .stdin(Stdio::piped())
            .spawn()
            .map_err(|e| format!("Failed to spawn pbcopy: {}", e))?;
        
        if let Some(stdin) = child.stdin.as_mut() {
            stdin.write_all(text.as_bytes())
                .map_err(|e| format!("Failed to write to pbcopy: {}", e))?;
        }
        
        let status = child.wait()
            .map_err(|e| format!("Failed to wait for pbcopy: {}", e))?;
        
        if status.success() {
            println!("‚úÖ Clipboard write successful (macOS)");
            Ok(())
        } else {
            Err("Clipboard write failed (macOS)".to_string())
        }
    }
    
    #[cfg(target_os = "linux")]
    {
        use std::process::{Command, Stdio};
        use std::io::Write;
        
        // xclip„ÇíË©¶Ë°å
        let mut child = Command::new("xclip")
            .args(["-selection", "clipboard"])
            .stdin(Stdio::piped())
            .spawn();
        
        if let Ok(mut child_proc) = child {
            if let Some(stdin) = child_proc.stdin.as_mut() {
                if stdin.write_all(text.as_bytes()).is_ok() {
                    if let Ok(status) = child_proc.wait() {
                        if status.success() {
                            println!("‚úÖ Clipboard write successful (Linux/xclip)");
                            return Ok(());
                        }
                    }
                }
            }
        }
        
        // xclip„ÅåÂ§±Êïó„Åó„ÅüÂ†¥Âêà„ÄÅxsel„ÇíË©¶Ë°å
        let mut child = Command::new("xsel")
            .args(["-b", "-i"])
            .stdin(Stdio::piped())
            .spawn()
            .map_err(|e| format!("Failed to spawn xsel: {}", e))?;
        
        if let Some(stdin) = child.stdin.as_mut() {
            stdin.write_all(text.as_bytes())
                .map_err(|e| format!("Failed to write to xsel: {}", e))?;
        }
        
        let status = child.wait()
            .map_err(|e| format!("Failed to wait for xsel: {}", e))?;
        
        if status.success() {
            println!("‚úÖ Clipboard write successful (Linux/xsel)");
            Ok(())
        } else {
            Err("Clipboard write failed (Linux)".to_string())
        }
    }
    
    #[cfg(not(any(target_os = "windows", target_os = "macos", target_os = "linux")))]
    {
        Err("Clipboard operation not supported on this platform".to_string())
    }
}

/**
 * „ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„Çâ„ÉÜ„Ç≠„Çπ„Éà„ÇíË™≠„ÅøËæº„ÇÄ
 * Windows/macOS/LinuxÂØæÂøú
 */
#[tauri::command]
fn read_clipboard() -> Result<String, String> {
    println!("üìã Reading from clipboard");
    
    #[cfg(target_os = "windows")]
    {
        use std::process::Command;
        let output = Command::new("powershell")
            .args(["-Command", "Get-Clipboard"])
            .output()
            .map_err(|e| format!("Failed to execute clipboard read command: {}", e))?;
        
        if output.status.success() {
            let text = String::from_utf8_lossy(&output.stdout).trim().to_string();
            println!("‚úÖ Clipboard read successful (Windows): {} characters", text.len());
            Ok(text)
        } else {
            Err("Clipboard read failed (Windows)".to_string())
        }
    }
    
    #[cfg(target_os = "macos")]
    {
        use std::process::Command;
        let output = Command::new("pbpaste")
            .output()
            .map_err(|e| format!("Failed to execute pbpaste: {}", e))?;
        
        if output.status.success() {
            let text = String::from_utf8_lossy(&output.stdout).to_string();
            println!("‚úÖ Clipboard read successful (macOS): {} characters", text.len());
            Ok(text)
        } else {
            Err("Clipboard read failed (macOS)".to_string())
        }
    }
    
    #[cfg(target_os = "linux")]
    {
        use std::process::Command;
        
        // xclip„ÇíË©¶Ë°å
        let output = Command::new("xclip")
            .args(["-selection", "clipboard", "-o"])
            .output();
        
        if let Ok(output) = output {
            if output.status.success() {
                let text = String::from_utf8_lossy(&output.stdout).to_string();
                println!("‚úÖ Clipboard read successful (Linux/xclip): {} characters", text.len());
                return Ok(text);
            }
        }
        
        // xclip„ÅåÂ§±Êïó„Åó„ÅüÂ†¥Âêà„ÄÅxsel„ÇíË©¶Ë°å
        let output = Command::new("xsel")
            .args(["-b", "-o"])
            .output()
            .map_err(|e| format!("Failed to execute xsel: {}", e))?;
        
        if output.status.success() {
            let text = String::from_utf8_lossy(&output.stdout).to_string();
            println!("‚úÖ Clipboard read successful (Linux/xsel): {} characters", text.len());
            Ok(text)
        } else {
            Err("Clipboard read failed (Linux)".to_string())
        }
    }
    
    #[cfg(not(any(target_os = "windows", target_os = "macos", target_os = "linux")))]
    {
        Err("Clipboard operation not supported on this platform".to_string())
    }
}

// =====================================================
// „Éï„Ç°„Ç§„É´Êìç‰ΩúÔºàË™≠„ÅøÊõ∏„Åç„ÅÆ„Åø„ÄÅ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÅØJavaScriptÂÅ¥„ÅßÂá¶ÁêÜÔºâ
// =====================================================

/**
 * „Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÄ
 */
#[tauri::command]
async fn read_file(path: String) -> Result<String, String> {
    println!("üìñ Reading file: {}", path);
    
    match std::fs::read_to_string(&path) {
        Ok(content) => {
            println!("‚úÖ File read successfully: {} characters", content.len());
            Ok(content)
        },
        Err(e) => {
            let error_msg = format!("Failed to read file '{}': {}", path, e);
            println!("‚ùå {}", error_msg);
            Err(error_msg)
        }
    }
}

/**
 * „Éï„Ç°„Ç§„É´„Å´Êõ∏„ÅçËæº„ÇÄ
 */
#[tauri::command]
async fn write_file(path: String, content: String) -> Result<(), String> {
    println!("üíæ Writing file: {} ({} characters)", path, content.len());
    
    match std::fs::write(&path, &content) {
        Ok(_) => {
            println!("‚úÖ File written successfully: {}", path);
            Ok(())
        },
        Err(e) => {
            let error_msg = format!("Failed to write file '{}': {}", path, e);
            println!("‚ùå {}", error_msg);
            Err(error_msg)
        }
    }
}

// =====================================================
// „Éï„Ç°„Ç§„É´„Éâ„É≠„ÉÉ„Éó„Éè„É≥„Éâ„É™„É≥„Ç∞ÔºàTauri 2.6ÂØæÂøúÔºâ
// =====================================================

/**
 * „Éï„Ç°„Ç§„É´„Éâ„É≠„ÉÉ„Éó„Ç§„Éô„É≥„Éà„ÇíÂá¶ÁêÜ„Åô„Çã„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
 */
fn handle_file_drop_event(app_handle: &AppHandle, file_path: &str) {
    println!("üìÇ File drop event: {}", file_path);
    
    // Êñ∞„Åó„ÅÑ„Ç¶„Ç£„É≥„Éâ„Ç¶„Çí‰ΩúÊàê„Åó„Å¶„Éï„Ç°„Ç§„É´„ÇíÈñã„Åè
    match tauri::WebviewWindowBuilder::new(
        app_handle,
        format!("editor_{}", chrono::Utc::now().timestamp_millis()),
        tauri::WebviewUrl::App("index.html".into())
    )
    .title(format!("Sert - {}", std::path::Path::new(file_path).file_name().unwrap_or_default().to_string_lossy()))
    .build() {
        Ok(window) => {
            println!("‚úÖ New window created for dropped file");
            
            // Êñ∞„Åó„ÅÑ„Ç¶„Ç£„É≥„Éâ„Ç¶„Å´„Éï„Ç°„Ç§„É´„Éë„Çπ„ÇíÈÄÅ‰ø°
            if let Err(e) = window.emit("file-dropped", file_path) {
                println!("‚ùå Failed to emit file-dropped event to new window: {}", e);
            }
        },
        Err(e) => {
            println!("‚ùå Failed to create new window: {}", e);
            
            // Êñ∞„Åó„ÅÑ„Ç¶„Ç£„É≥„Éâ„Ç¶‰ΩúÊàê„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÄÅÊó¢Â≠ò„ÅÆ„Ç¶„Ç£„É≥„Éâ„Ç¶„Å´ÈÄÅ‰ø°
            if let Some(window) = app_handle.get_webview_window("main") {
                if let Err(e) = window.emit("file-dropped", file_path) {
                    println!("‚ùå Failed to emit file-dropped event to main window: {}", e);
                }
            }
        }
    }
}

// =====================================================
// „É°„Ç§„É≥Èñ¢Êï∞„Å®„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö
// =====================================================

fn main() {
    // PyO3„ÅÆÂàùÊúüÂåñ
    pyo3::prepare_freethreaded_python();
    
    // „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„ÅÆ„É≠„Ç∞Âá∫Âäõ
    let args: Vec<String> = std::env::args().collect();
    println!("üöÄ Sert Editor starting with args: {:?}", args);
    
    tauri::Builder::default()
        // „Éó„É©„Ç∞„Ç§„É≥„ÅÆÂàùÊúüÂåñ
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_shell::init())
        
        // Tauri„Ç≥„Éû„É≥„Éâ„ÅÆÁôªÈå≤
        .invoke_handler(tauri::generate_handler![
            // „Éï„Ç°„Ç§„É´Èñ¢ÈÄ£‰ªò„Åë„Éª„Éâ„É≠„ÉÉ„ÉóÊ©üËÉΩ
            get_startup_file_path,
            validate_file_path,
            get_file_info,
            
            // PythonÈñ¢ÈÄ£
            test_python,
            execute_python,
            evaluate_python_expression,
            run_python_file,
            get_python_info,
            
            // „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Âà∂Âæ°
            exit_app,
            
            // „ÇØ„É™„ÉÉ„Éó„Éú„Éº„ÉâÊìç‰Ωú
            write_clipboard,
            read_clipboard,
            
            // „Éï„Ç°„Ç§„É´Êìç‰Ωú
            read_file,
            write_file
        ])
        
        // „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂàùÊúüÂåñÂá¶ÁêÜ
        .setup(|app| {
            println!("üöÄ Sert Editor starting up...");
            
            // „Ç¶„Ç£„É≥„Éâ„Ç¶„ÅÆÂèñÂæó„Å®Ë®≠ÂÆö
            let windows = app.webview_windows();
            if let Some(window) = windows.get("main") {
                println!("‚úÖ Main window found and configured for multi-display support");
                
                #[cfg(target_os = "macos")]
                {
                    println!("üñ•Ô∏è macOS multi-display support enabled via configuration");
                }
                
                #[cfg(not(target_os = "macos"))]
                {
                    println!("üñ•Ô∏è Multi-display support enabled via configuration");
                }
            } else {
                println!("‚ö†Ô∏è Main window not found, using default configuration");
            }
            
            // PyO3„ÅÆÂàùÊúüÂåñ„ÉÜ„Çπ„Éà
            println!("üêç Testing PyO3 integration...");
            match test_python() {
                Ok(result) => println!("‚úÖ PyO3 test successful: {}", result),
                Err(e) => println!("‚ùå PyO3 test failed: {}", e),
            }
            
            // PythonÁí∞Â¢ÉÊÉÖÂ†±„ÅÆË°®Á§∫
            match get_python_info() {
                Ok(info) => println!("‚úÖ {}", info),
                Err(e) => println!("‚ùå Python info error: {}", e),
            }
            
            println!("üìã Clipboard operations enabled");
            println!("üìÅ File operations enabled (JavaScript-based dialogs)");
            println!("üóÇÔ∏è Drag and drop functionality enabled");
            println!("üîó File association support enabled");
            println!("üéØ Sert Editor ready!");
            
            Ok(())
        })
        
        // „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂÆüË°å
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}